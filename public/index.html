<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <title>LateLight</title>

    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Quiet Apartment">

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com/css2">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Midnight Theme Variables (from stats.html) */
            --bg: #000000;
            --text: #ffffff;
            --text-dim: #888888;
            --gold: #FFDBAC;
            --cyan: #00FFFF;
            --magenta: #FF00FF;
            --bar-bg: #1A1A1A;
            --card-surface: rgba(20, 20, 20, 0.4);
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);

            /* Legacy Mappings / Adjustments */
            --light-base: rgba(255, 219, 172, 0.7);
            /* Gold-ish */
            --light-glow: rgba(255, 219, 172, 0.6);
            --light-dev: rgba(200, 240, 255, 0.8);
            --dev-glow: rgba(100, 200, 255, 0.6);
            --light-rest: rgba(0, 255, 255, 0.6);
            /* Cyan-ish */
            --rest-glow: rgba(0, 255, 255, 0.4);

            --ui-bg: var(--card-surface);
            --ui-border: rgba(255, 255, 255, 0.05);
            /* Thinner border */
            --ui-text: var(--text);
            --ui-accent: var(--gold);
            --ui-rest: var(--cyan);

            --glass-blur: blur(12px);
            --shadow-soft: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        body {
            margin: 0;
            background-color: var(--bg);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            color: var(--ui-text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            touch-action: none;
        }

        /* Transitions */
        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.5s ease;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
        }

        .slide-up-enter-active,
        .slide-up-leave-active {
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .slide-up-enter-from,
        .slide-up-leave-to {
            opacity: 0;
            transform: translateY(20px) translateX(-50%);
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: auto;
            left: auto;
            transform: none;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
            pointer-events: none;
        }

        .toast {
            background: rgba(0, 0, 0, 0.95);
            /* Solid dark background */
            border: 1px solid var(--gold);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 8px;
            /* Sharper corners */
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(255, 219, 172, 0.2);
            backdrop-filter: var(--glass-blur);
            animation: toastIn 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Modal / Settings */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            z-index: 11000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--card-surface);
            border: 1px solid var(--ui-border);
            border-radius: 20px;
            padding: 25px;
            width: 85%;
            max-width: 320px;
            box-shadow: var(--shadow-soft);
            color: var(--text);
            backdrop-filter: var(--glass-blur);
        }

        .modal-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close {
            cursor: pointer;
            opacity: 0.6;
            font-size: 20px;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-size: 13px;
        }

        .setting-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            border-radius: 8px;
            padding: 4px 8px;
            width: 60px;
            text-align: center;
        }

        .setting-radio-group {
            display: flex;
            gap: 10px;
        }

        .setting-radio-label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #aaa;
        }

        .setting-radio-label input {
            accent-color: var(--ui-accent);
        }

        .setting-radio-label.active {
            color: #fff;
        }

        .close-stats-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            right: auto;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .close-stats-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: scale(1.05);
        }


        /* Refactored Layout: Wrapper Strategy */

        #rotate-message {
            display: none !important;
        }

        body {
            margin: 0;
            background-color: #000;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            /* No flex center on body needed anymore */
        }

        #app {
            /* App is the fixed Viewport Container */
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            /* Flex center removed, relying on .game-container absolute centering */
        }

        /* New Wrapper for Image Content */
        .game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);

            /* Sizing Logic (Width Fit) */
            width: 100vw;
            /* Aspect Ratio Constraint: 16:9 = ~1.77 */
            max-width: 177.78vh;
            height: auto;

            display: flex;
            justify-content: center;
            align-items: center;

            z-index: 1;
            /* Content layer */
            /* Content layer */
            z-index: 1;
            /* Content layer */
            cursor: default;
            /* Reset cursor */

            /* Enable Container Queries */
            container-type: inline-size;
        }

        /* Dev Recording Mode Cursor */
        .game-container.is-dev-recording {
            cursor: crosshair;
        }

        .bg-image {
            width: 100%;
            height: auto;
            display: block;
            pointer-events: none;
            filter: brightness(0.75) contrast(1.05);
            /* Balanced darkness */
            transition: filter 1s ease;
        }

        /* Overlays relative to .game-container */
        .lights-layer,
        .room-reflection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* =========================================
           SPLIT LAYOUT: Timer (Center) & Controls (Bottom)
           ========================================= */

        /* 1. Timer Centered */
        .timer-centered {
            position: absolute;
            /* Changed from fixed to absolute (relative to game-container) */
            top: 50%;
            /* Dead center */
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;

            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;

            /* Optional: Transparent or subtle backing? */
            /* User asked for numbers to be focused. No heavy box needed. */
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            /* Allow clicks to pass through empty space */
            transition: all 0.5s ease-in-out;
            /* Smooth transition when moving */
        }

        /* 1-B. Timer at Bottom (Room Mode / Shrunk) */
        .timer-centered.room-view {
            top: auto;
            /* Release Top */
            bottom: 150px;
            /* Sit above the controls */
            transform: translateX(-50%);
            /* Only center horizontally */
        }

        /* 2. Controls Fixed to Bottom */
        .controls-bottom {
            position: fixed;
            /* Safe area support for Home Indicator */
            bottom: max(30px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;

            display: flex;
            justify-content: center;
            align-items: center;

            /* No background - just a transparent container for positioning */
            background: transparent;
            padding: 0;
            border-radius: 0;
            backdrop-filter: none;
            border: none;
            box-shadow: none;

            width: auto;
        }

        .controls {
            display: flex;
            flex-direction: column;
            /* Vertical Stack */
            gap: 20px;
            /* Space between Start and Maximize */
            justify-content: flex-end;
            align-items: center;
            width: 100%;
            position: relative;
            /* For absolutely positioned Minimize btn */
        }

        .timer-display {
            /* Responsive but capped font size, using cqw relative to game-container */
            font-size: 12cqw;
            /* Adjusted for container relative sizing */
            font-family: 'Courier New', monospace;
            /* Monospaced to prevent jitter */
            font-weight: bold;
            letter-spacing: 2px;
            color: #fff;
            white-space: nowrap;
            user-select: none;
            -webkit-user-select: none;
            cursor: pointer;
            pointer-events: auto;
            /* Enable clicks on text */
        }



        .controls button {
            background: transparent;
            color: #ddd;
            border: 1px solid #555;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
        }

        .controls button:hover {
            color: #fff;
            border-color: #fff;
        }

        .timer-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        /* Controls - Fixed to SCREEN, not Image */
        .top-left-controls {
            position: fixed;
            /* Use Safe Area Insets for Notch/Status Bar support */
            top: max(30px, env(safe-area-inset-top));
            left: max(30px, env(safe-area-inset-left));
            z-index: 3000;
            /* Super high to sit above everything */

            display: flex;
            gap: 15px;
            /* Add spacing between buttons */
        }

        /* Reset all previous window styles (They need new % coordinates) */
        /* You can comment these out or leave them for user to update */

        /* 通常の窓 */
        .light {
            position: absolute;
            background-color: var(--light-base);
            box-shadow: 0 0 6px 1px var(--light-glow);
            mix-blend-mode: screen;
            opacity: 0;
            transition: opacity 3s ease-in-out, background-color 3s;
            /* transform: translate(-50%, -50%); - Removed for Rect Mode coordinates */
        }

        .light.is-active {
            opacity: 1;
        }

        .light.is-dev-room {
            background-color: var(--light-dev) !important;
            box-shadow: 0 0 10px 2px var(--dev-glow) !important;
            z-index: 3;
        }

        /* 休憩中の窓スタイル */
        .light.is-resting {
            background-color: var(--light-rest) !important;
            box-shadow: 0 0 8px 2px var(--rest-glow) !important;
        }

        /* 自分の部屋の明かり（窓ガラスへの反射と枠の照り返し） */
        .room-reflection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            /* 背景画像より手前、UIより奥 */
            pointer-events: none;
            /* クリックを透過 */
            opacity: 0;
            transition: opacity 2s ease-in-out;
            /* ふんわり点灯 */

            /* A案: グレア */
            background: radial-gradient(circle at 50% 150%, rgba(255, 200, 100, 0.2), transparent 70%);
            /* B案: 窓枠の照り返し */
            box-shadow: inset 0 0 80px rgba(255, 210, 120, 0.15);
            /* フィルター */
            backdrop-filter: sepia(20%) brightness(1.1);
        }

        /* 点灯状態 */
        .room-reflection.is-active {
            opacity: 1;
        }

        /* UI */
        .dashboard {
            position: absolute;
            left: 50%;
            bottom: 5%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
            background: var(--card-surface);
            padding: 12px 28px;
            border-radius: 24px;
            /* Slightly less rounded to match cards? Or keep pill */
            backdrop-filter: var(--glass-blur);
            border: 1px solid var(--ui-border);
            box-shadow: var(--shadow-soft);
            transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .dashboard.focus-mode {
            opacity: 0.4;
        }

        .dashboard.focus-mode:hover {
            opacity: 1;
        }

        /* 休憩中のUIスタイル変更 */
        .dashboard.rest-mode {
            border-color: var(--ui-rest);
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.1);
        }

        .dashboard.rest-mode .timer-display {
            color: var(--ui-rest);
        }

        /* ... info-group, neighbor-count ... */

        .timer-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 1px;
            transition: color 0.5s;
        }

        /* ... */

        button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 11px;
            padding: 4px 8px;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
        }

        button:hover {
            color: var(--text);
        }

        button.primary {
            color: var(--gold);
            /* Gold text */
            font-weight: bold;
            border: 1px solid rgba(255, 219, 172, 0.3);
            /* Goldish border */
            border-radius: 30px;
            padding: 10px 40px;
            font-size: 14px;
            letter-spacing: 2px;
            background: rgba(255, 219, 172, 0.05);
            backdrop-filter: blur(4px);
            min-width: 140px;
            transition: all 0.3s ease;
        }

        button.primary:hover {
            background: rgba(255, 219, 172, 0.2);
            border-color: var(--gold);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 219, 172, 0.1);
        }

        /* ... dimmed, mode-text ... */

        .icon-circle-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--card-surface);
            border: 1px solid var(--ui-border);
            color: var(--text-dim);
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
            cursor: pointer;
            transition: all 0.2s;
        }

        .icon-circle-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text);
            border-color: var(--gold);
            transform: scale(1.05);
        }

        .icon-circle-btn svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            stroke-width: 1.5;
            fill: none;
        }

        .tab-btn {
            background: var(--ui-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            backdrop-filter: blur(4px);
            cursor: pointer;
        }

        .tab-btn.active {
            color: var(--ui-accent);
            border-color: var(--ui-accent);
            font-weight: bold;
        }

        .stats-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 90;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .stats-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .chart-container {
            width: 80%;
            height: 60%;
            position: relative;
        }

        .period-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .period-btn {
            font-size: 12px;
            color: #888;
            cursor: pointer;
            padding: 4px 10px;
            border-bottom: 2px solid transparent;
        }

        .period-btn.active {
            color: #fff;
            border-bottom-color: var(--ui-accent);
        }

        .empty-logs {
            color: #666;
            font-size: 12px;
            margin-top: 20px;
        }



        @keyframes rotatePhone {
            0% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(90deg);
            }

            100% {
                transform: rotate(0deg);
            }
        }

        /* 時計モード時のダッシュボード */
        #app.clock-mode .dashboard {
            /* 配置ロジック変更 (X軸維持、Y軸中央へ) */
            top: 50%;
            bottom: auto;
            transform: translate(-50%, -50%);
            /* X:-50% Y:-50% */

            width: 100%;
            height: 100%;

            justify-content: center;
            flex-direction: column;
            gap: 25px;
            padding: 0;

            background: transparent;
            border: none;
            box-shadow: none;
            backdrop-filter: none;
        }

        /* 時計モード時のタイマー文字サイズ */
        /* 極細(100)、文字間隔標準(0)で背景を見やすく */
        #app.clock-mode .timer-display {
            font-size: 22vw;
            /* Webフォント 'Inter' を優先指定 */
            font-family: 'Inter', 'Helvetica Neue', Arial, sans-serif;
            font-weight: 100;
            letter-spacing: 0;
            line-height: 1;
            text-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            width: 100%;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        /* 時計モード時に不要な要素を隠す */
        #app.clock-mode .info-group,
        /* Only hide buttons that are NOT primary AND NOT icon-circle-btn */
        #app.clock-mode .controls button:not(.icon-circle-btn):not(.primary) {
            display: none;
        }

        /* 時計モード時のコントロール配置調整 */
        /* 時計モード時のコントロール配置調整 - REMOVED for Unified UI */
        /* Controls will now stay inside the fixed dashboard */

        /* アイコンボタンのスタイル */
        /* Icon Circle Button (Better Visibility) */
        .icon-circle-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            /* Darker background */
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            color: #fff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .icon-circle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        /* SVG Icon Style for Circle Btn */
        .icon-circle-btn svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
            stroke-width: 1.5;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .icon-btn.minimize-btn {
            /* Position absolutey so it doesn't affect Start button centering */
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            margin: 0;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: #fff;
            transform: scale(1.1);
            /* ホバー時にハッキリ表示 */
            opacity: 1;
        }

        /* SVGアイコンのスタイル */
        .icon-btn svg {
            width: 20px;
            height: 20px;
            stroke: currentColor;
            stroke-width: 1.5;
            /* 細めの線画 */
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* 座標設定 (User Defined - Rect V2) */
        .w-0 {
            top: 38.05%;
            left: 21.62%;
            width: 2.75%;
            height: 1.58%;
        }

        .w-1 {
            top: 42.42%;
            left: 21.62%;
            width: 2.83%;
            height: 1.58%;
        }

        .w-2 {
            top: 46.74%;
            left: 21.54%;
            width: 3.22%;
            height: 1.68%;
        }

        .w-3 {
            top: 38.05%;
            left: 26.89%;
            width: 2.75%;
            height: 1.58%;
        }

        .w-4 {
            top: 42.42%;
            left: 26.89%;
            width: 2.91%;
            height: 1.63%;
        }

        .w-5 {
            top: 46.74%;
            left: 26.89%;
            width: 3.07%;
            height: 1.68%;
        }

        .w-6 {
            top: 38.00%;
            left: 32.55%;
            width: 1.57%;
            height: 1.47%;
        }

        .w-7 {
            top: 42.37%;
            left: 32.39%;
            width: 1.65%;
            height: 1.53%;
        }

        .w-8 {
            top: 46.68%;
            left: 32.23%;
            width: 1.73%;
            height: 1.68%;
        }

        .w-9 {
            top: 38.05%;
            left: 38.99%;
            width: 4.17%;
            height: 1.53%;
        }

        .w-10 {
            top: 42.42%;
            left: 39.07%;
            width: 4.17%;
            height: 1.58%;
        }

        .w-11 {
            top: 46.79%;
            left: 38.99%;
            width: 4.25%;
            height: 1.63%;
        }

        .w-12 {
            top: 38.00%;
            left: 45.83%;
            width: 2.44%;
            height: 1.63%;
        }

        .w-13 {
            top: 42.37%;
            left: 45.75%;
            width: 2.67%;
            height: 1.74%;
        }

        .w-14 {
            top: 46.74%;
            left: 45.75%;
            width: 2.59%;
            height: 1.53%;
        }

        .w-15 {
            top: 38.00%;
            left: 51.02%;
            width: 2.52%;
            height: 1.58%;
        }

        .w-16 {
            top: 42.42%;
            left: 51.10%;
            width: 2.52%;
            height: 1.63%;
        }

        .w-17 {
            top: 46.79%;
            left: 51.02%;
            width: 2.59%;
            height: 1.68%;
        }

        .w-18 {
            top: 38.05%;
            left: 56.53%;
            width: 4.09%;
            height: 1.42%;
        }

        .w-19 {
            top: 42.58%;
            left: 56.53%;
            width: 3.77%;
            height: 1.32%;
        }

        .w-20 {
            top: 46.84%;
            left: 56.53%;
            width: 3.93%;
            height: 1.47%;
        }

        .w-21 {
            top: 38.05%;
            left: 65.64%;
            width: 1.65%;
            height: 1.68%;
        }

        .w-22 {
            top: 42.47%;
            left: 65.64%;
            width: 1.57%;
            height: 1.63%;
        }

        .w-23 {
            top: 46.74%;
            left: 65.64%;
            width: 1.65%;
            height: 1.79%;
        }

        .w-24 {
            top: 38.10%;
            left: 69.26%;
            width: 2.67%;
            height: 1.53%;
        }

        .w-25 {
            top: 42.47%;
            left: 69.58%;
            width: 2.52%;
            height: 1.58%;
        }

        .w-26 {
            top: 46.84%;
            left: 69.50%;
            width: 2.75%;
            height: 1.58%;
        }

        .w-27 {
            top: 38.15%;
            left: 75.71%;
            width: 4.01%;
            height: 1.26%;
        }

        .w-28 {
            top: 42.47%;
            left: 75.79%;
            width: 3.77%;
            height: 1.47%;
        }

        .w-29 {
            top: 46.53%;
            left: 75.71%;
            width: 4.25%;
            height: 2.00%;
        }

        /* --- Pause Overlay --- */
        .pause-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            /* Lighter dark */
            backdrop-filter: none;
            /* No blur per user request */
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            animation: fadeIn 0.3s;
            padding-top: 25vh;
            /* Shift content down below timer */
        }

        .pause-content {
            text-align: center;
            width: 90%;
            max-width: 400px;
            pointer-events: auto;
            /* Ensure clickable */
        }

        /* ... existing styles ... */
        .pause-content h2 {
            font-size: 24px;
            letter-spacing: 4px;
            color: #fff;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        /* --- Tag Settings Modal --- */
        .tag-modal {
            max-width: 350px;
            pointer-events: auto;
        }

        .tag-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding-right: 5px;
        }

        /* Custom Scrollbar for tag list */
        .tag-list::-webkit-scrollbar {
            width: 4px;
        }

        .tag-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .tag-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 14px;
            transition: background 0.2s;
            border: 1px solid transparent;
        }

        .tag-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .delete-tag-btn {
            background: transparent;
            color: #888;
            border: none;
            font-size: 18px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0;
            margin-left: 10px;
        }

        .delete-tag-btn:hover {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            transform: scale(1.1);
        }

        .add-tag-row {
            position: relative;
            display: flex;
            align-items: center;
        }

        .add-tag-row input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--ui-border);
            color: #fff;
            padding: 12px 15px;
            border-radius: 12px;
            font-size: 14px;
            outline: none;
            transition: all 0.2s;
        }

        .add-tag-row input:focus {
            border-color: var(--ui-accent);
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 10px rgba(255, 219, 172, 0.1);
        }

        /* --- Note Icon on Desk (Now Integrated) --- */
        .icon-note {
            position: relative;
            /* Changed from fixed */
            /* bottom/right removed */
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.9;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s, background 0.2s;
            /* z-index removed as it is in flow */
            backdrop-filter: blur(4px);
        }

        .icon-note:hover {
            opacity: 1;
            transform: scale(1.1);
            background: rgba(255, 204, 0, 0.3);
            border-color: var(--ui-accent);
        }

        /* --- Pause Animation & Styles --- */
        .timer-centered {
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }

        /* Slide up when paused to make room for menu */
        /* IMPORTANT: Must maintain translateX(-50%) for horizontal centering! */
        .timer-centered.paused-move-up {
            transform: translate(-50%, -45vh) scale(0.5);
        }

        .pause-overlay {
            /* Ensure it centers content */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-top: 15vh;
            /* Shift content down slightly as requested */
        }

        .resume-btn {
            font-size: 1.8rem;
            padding: 15px 60px;
            margin-bottom: 40px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.4);
            color: #fff;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .resume-btn:hover {
            background: rgba(255, 255, 255, 1);
            color: #000;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .pause-tags {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            width: 100%;
            max-width: 320px;
            /* Tighter width for better mobile focus */
            margin: 0 auto;
        }

        .pause-tags button {
            font-size: 1rem;
            padding: 16px 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(10px);
            color: #eee;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            font-weight: 500;
            width: 100%;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;
            letter-spacing: 1px;
        }

        .pause-tags button:hover {
            border-color: var(--gold);
            color: #fff;
            background: rgba(255, 219, 172, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255, 219, 172, 0.1);
        }



        .pause-tags .add-tag-btn {
            grid-column: span 2;
            /* Full width for 'Add' */
            font-weight: bold;
            font-size: 1.2rem;
            padding: 12px;
            border-style: dashed;
            opacity: 0.8;
        }

        .pause-tags .add-tag-btn:hover {
            opacity: 1;
            border-style: solid;
        }

        .fade-in {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 20px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .controls-bottom {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 10000;
            /* Ensure visible above overlay */
        }
    </style>
</head>

<body>

    <div id="app">
        <div class="game-container">
            <img src="bg-portrait.jpg" class="bg-image">
            <div class="room-reflection" :class="{ 'is-active': isRunning }"></div>
            <!-- Old top-left-controls block removed (Consolidated below) -->
            <div class="toast-container">
                <div v-for="msg in toasts" :key="msg.id" class="toast">
                    {{ msg.text }}
                </div>
            </div>

            <!-- lights-layer -->
            <div class="lights-layer">
                <div v-for="(isOn, index) in windows" :key="index" class="light" :class="['w-' + index, { 
                'is-active': isOn && index !== myRoomIndex, 
                'is-dev-room': index === 14 && isOn && index !== myRoomIndex,
                'is-resting': isResting && index === myRoomIndex
            }]"></div>
            </div>

            <!-- Timer Area (Moved Inside Game Container for Scaling) -->
            <div class="timer-centered"
                :class="{ 'focus-mode': isRunning, 'rest-mode': isResting, 'room-view': !isClockMode, 'paused-move-up': isPaused }"
                v-show="currentTab === 'room'">
                <div class="info-group">
                    <div class="neighbor-count">
                        <div class="live-dot"></div>{{ activeNeighbors }} 人が集中
                    </div>
                    <div class="total-time">合計: {{ formattedTotalTime }}
                        <span class="save-status" :class="{ 'saved': isSaved }">●</span>
                    </div>
                </div>
                <!-- Timer Display -->
                <div class="timer-display" @click="cycleTimerDuration" :class="{ 'clickable': mode === 'pomodoro' }">
                    {{ formattedTime }}
                </div>
            </div>
        </div>
        <!-- End of game-container -->

        <!-- Pause Overlay -->
        <transition name="fade">
            <div class="pause-overlay" v-if="isPaused">
                <div class="pause-content">
                    <!-- Resume button removed per user request -->
                    <div class="pause-divider"></div>
                    <p class="fade-in">タグを選択して終了</p>
                    <div class="pause-tags">
                        <button v-for="tag in tags" :key="tag" @click="finishSession(tag)">{{ tag }}</button>
                        <button class="add-tag-btn" @click="isTagEditMode = true; showSettings = true">+</button>
                    </div>
                </div>
            </div>
        </transition>



        <transition name="fade">
            <div class="modal-overlay" v-if="showSettings" @click.self="saveSettings">
                <div class="modal-content">
                    <div class="modal-header"><span>{{ isTagEditMode ? 'タグ管理' : '設定' }}</span><span class="modal-close"
                            @click="saveSettings">✕</span>
                    </div>
                    <div class="setting-row" v-if="!isTagEditMode && settings.mode === 'timer'"><span>集中時間
                            (分)</span><input type="number" v-model.number="settings.pomodoro" class="setting-input"
                            min="1" max="120"></div>


                    <!-- Tag Management (Embedded) -->
                    <div style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                        <div style="margin-bottom:10px; font-size:14px; color:#aaa;">タグ管理</div>
                        <div class="tag-list" style="max-height: 120px; margin-bottom: 10px;">
                            <div v-for="(tag, index) in tags" :key="index" class="tag-item"
                                style="padding: 6px 10px; font-size: 13px;">
                                <span>{{ tag }}</span>
                                <button class="delete-tag-btn" @click="deleteTag(index)"
                                    style="font-size: 14px;">✕</button>
                            </div>
                        </div>
                        <div class="add-tag-row">
                            <input type="text" placeholder="新しいタグ" v-model="newTagInput"
                                @keyup.enter="addTag(newTagInput)" style="padding: 8px; font-size: 13px;">
                        </div>
                    </div>

                    <!-- Data Transfer (ID Based) - Hidden in Tag Edit Mode -->
                    <div v-if="!isTagEditMode"
                        style="margin-top: 25px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                        <div style="margin-bottom:10px; font-size:14px; color:#aaa;">データ引き継ぎ (ID)</div>

                        <!-- Current ID -->
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #888; margin-bottom: 4px;">現在のID (コピー)</div>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" :value="userId" readonly class="setting-input"
                                    style="flex: 1; font-size: 11px; color: #fff; background: rgba(255,255,255,0.05); width: auto;"
                                    @click="copyText(userId)">
                                <button class="primary" style="padding: 4px 10px; font-size: 12px; min-width: 60px;"
                                    @click="copyText(userId)">コピー</button>
                            </div>
                        </div>

                        <!-- Import ID -->
                        <div>
                            <div style="font-size: 11px; color: #888; margin-bottom: 4px;">IDを入力してデータを復元</div>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" v-model="importUserId" placeholder="移行元のIDを入力" class="setting-input"
                                    style="flex: 1; font-size: 11px; text-align: left; padding-left: 8px; width: auto; color: #fff;">
                                <button class="primary" style="padding: 4px 10px; font-size: 12px; min-width: 60px;"
                                    @click="updateUserId">更新</button>
                            </div>
                        </div>
                    </div>

                    <div style="text-align: right; margin-top: 20px;"><button class="primary"
                            @click="saveSettings">保存</button></div>
                </div>
            </div>
        </transition>

        <div class="top-left-controls" v-if="!isRunning && !isResting">
            <!-- Toggle Screen (Records <-> Room) -->
            <div class="icon-circle-btn" @click="toggleScreen"
                :title="currentTab === 'room' ? 'Go to Records' : 'Back to Room'">
                <!-- Chart Icon (Show in Room) --><svg v-if="currentTab === 'room'" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2">
                    <path d="M18 20V10M12 20V4M6 20v-6"></path>
                </svg>
                <!-- Home Icon (Show in Stats) --><svg v-else viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="2">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                </svg>
            </div>
            <!-- Toggle Mode (Stopwatch <-> Timer) -->
            <div class="icon-circle-btn" @click="toggleMode" v-if="currentTab === 'room'"
                :title="mode === 'pomodoro' ? 'Switch to Stopwatch' : 'Switch to Timer'"><svg v-if="mode === 'pomodoro'"
                    viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <polyline points="12 6 12 12 16 14"></polyline>
                </svg><svg v-else viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M10 2h4"></path>
                    <path d="M12 14v-4"></path>
                    <path d="M4 13a8 8 0 0 1 8-7 8 8 0 1 1-8 7"></path>
                </svg></div>
            <div class="icon-circle-btn" @click="isTagEditMode = false; showSettings = true" title="Settings">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path
                        d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                    </path>
                </svg>
            </div>
        </div>

        <!-- Timer Area Moved Inside Game Container -->

        <div class="controls-bottom" v-show="currentTab === 'room'">
            <!-- Note Icon Removed (Moved into .controls) -->
            <div class="controls" :class="{ 'dimmed': isRunning }">
                <!-- Maximize/Minimize Buttons (Top) --><button v-if="!isClockMode" class="icon-circle-btn"
                    @click="isClockMode = true" title="Maximize"><svg viewBox="0 0 24 24">
                        <path d="M15 3h6v6"></path>
                        <path d="M9 21H3v-6"></path>
                        <path d="M21 3l-7 7"></path>
                        <path d="M3 21l7-7"></path>
                    </svg></button><button v-if="isClockMode" class="icon-circle-btn" @click="isClockMode = false"
                    title="Minimize"><svg viewBox="0 0 24 24">
                        <path d="M4 14h6v6"></path>
                        <path d="M20 10h-6V4"></path>
                        <path d="M14 10l7-7"></path>
                        <path d="M10 14l-7 7"></path>
                    </svg></button><button v-if="!isRunning && !isResting && time > 0" @click="resetTimer">✕</button>

                <!-- Bottom Action Row -->
                <div style="display: flex; align-items: center; gap: 15px;">
                    <!-- Start/Stop Button --><button class="primary" @click="handleMainButton">
                        {{ isResting ? '休憩終了': (isPaused ? '再開' : (isRunning ? '停止' : '開始')) }}
                    </button>
                    <!-- Note Icon moved to corner -->
                </div>
            </div>

        </div>

    </div>
    <!-- "Midnight Console" Stats Overlay REMOVED (Moved to stats.html) -->
    <!-- Global Builds for Local Execution -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <script>
        // --- Shared Logic Inlined (formerly shared.js) ---
        const firebaseConfig = {
            apiKey: "AIzaSyApsAaSIFEh1BhRgl_sFPssLMOPLjnOqaE",
            authDomain: "late-light.firebaseapp.com",
            databaseURL: "https://late-light-default-rtdb.firebaseio.com",
            projectId: "late-light",
            storageBucket: "late-light.firebasestorage.app",
            messagingSenderId: "785315819458",
            appId: "1:785315819458:web:feda9dc1fb93f497f6b05b",
            measurementId: "G-C4HKZB6L22"
        };

        // Initialize Firebase (Compat)
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // Helper: Format Seconds
        const formatTimeStr = (s) => {
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
            return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        };

        const getWeekKey = (d) => {
            const s = new Date(d.getFullYear(), 0, 1);
            const w = Math.ceil((((d - s) / 86400000) + s.getDay() + 1) / 7);
            return d.getFullYear() + '-' + w;
        };

        // --- Main App Logic ---
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                const userId = ref('');
                const totalSeconds = ref(0);
                const isDev = ref(false);
                const isSaved = ref(true);
                const DEV_ROOM_INDEX = 14;
                const sessionStartTime = ref(null);

                // UI States
                const currentTab = ref('room');
                const showSettings = ref(false);
                const isTagEditMode = ref(false);
                const importUserId = ref('');
                const isPaused = ref(false);

                // Default Tags
                const tags = ref(JSON.parse(localStorage.getItem('qa_tags') || '[]'));

                // Toasts
                const toasts = ref([]);
                let toastId = 0;

                const showToast = (text) => {
                    const id = toastId++;
                    toasts.value.push({ id, text });
                    setTimeout(() => {
                        toasts.value = toasts.value.filter(t => t.id !== id);
                    }, 4000);
                };

                // Settings
                const savedSettings = JSON.parse(localStorage.getItem('qa_settings') || '{"pomodoro": 25, "rest": 5, "mode": "stopwatch"}');
                if (!savedSettings.mode || savedSettings.mode === 'pomodoro' || savedSettings.mode === 'timer') {
                    savedSettings.mode = 'stopwatch';
                }

                // Audio Context
                let alarmCtx = null;
                let alarmIntervalId = null;

                const playAlarm = () => {
                    if (alarmCtx) return;
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        if (AudioContext) {
                            alarmCtx = new AudioContext();
                            const beep = () => {
                                if (!alarmCtx) return;
                                const osc = alarmCtx.createOscillator();
                                const gain = alarmCtx.createGain();
                                osc.connect(gain);
                                gain.connect(alarmCtx.destination);
                                osc.type = 'sine';
                                osc.frequency.setValueAtTime(880, alarmCtx.currentTime);
                                gain.gain.setValueAtTime(0.05, alarmCtx.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.001, alarmCtx.currentTime + 0.5);
                                osc.start(alarmCtx.currentTime);
                                osc.stop(alarmCtx.currentTime + 0.5);
                            };
                            beep();
                            alarmIntervalId = setInterval(beep, 1500);
                        }
                    } catch (e) {
                        console.error("Audio access blocked", e);
                    }
                };

                const stopAlarm = () => {
                    if (alarmIntervalId) clearInterval(alarmIntervalId);
                    alarmIntervalId = null;
                    if (alarmCtx) {
                        try { alarmCtx.close(); } catch (e) { }
                        alarmCtx = null;
                    }
                };

                const settings = ref(savedSettings);

                const newTagInput = ref('');

                const toggleMode = () => {
                    if (mode.value === 'pomodoro') {
                        settings.value.mode = 'stopwatch';
                        mode.value = 'countup';
                    } else {
                        settings.value.mode = 'timer';
                        mode.value = 'pomodoro';
                    }
                    localStorage.setItem('qa_settings', JSON.stringify(settings.value));
                    if (!isRunning.value && !isResting.value) resetTimer();
                };

                const saveSettings = () => {
                    // 1. Auto-save any pending tag
                    if (newTagInput.value && newTagInput.value.trim().length > 0) {
                        addTag(newTagInput.value);
                    }

                    localStorage.setItem('qa_settings', JSON.stringify(settings.value));
                    showSettings.value = false;

                    const newMode = settings.value.mode === 'stopwatch' ? 'countup' : 'pomodoro';
                    const modeChanged = mode.value !== newMode;

                    if (modeChanged) {
                        mode.value = newMode;
                        // Always reset if mode changes as the session type is incompatible
                        resetTimer();
                    } else {
                        // If mode is same, only reset if we are at 0 (clean state).
                        // Do NOT reset if we are Paused (time > 0).
                        if (!isRunning.value && !isResting.value && time.value === 0) {
                            resetTimer();
                        }
                    }

                    // showToast('Settings saved.'); // User requested to remove this notification
                };

                const saveTags = () => localStorage.setItem('qa_tags', JSON.stringify(tags.value));
                const addTag = (name) => {
                    const trimmed = name.trim();
                    if (trimmed && !tags.value.includes(trimmed)) {
                        tags.value.push(trimmed);
                        saveTags();
                    }
                    newTagInput.value = ''; // update ref
                };
                const deleteTag = (index) => {
                    tags.value.splice(index, 1);
                    saveTags();
                };

                const TIMER_PRESETS = [25, 50, 60, 90];
                const cycleTimerDuration = () => {
                    if (mode.value !== 'pomodoro') return;
                    const currentMin = Math.floor((settings.value.focusTimeSeconds || (settings.value.pomodoro * 60)) / 60);
                    let nextIndex = TIMER_PRESETS.findIndex(p => p > currentMin);
                    if (nextIndex === -1) nextIndex = 0;
                    const nextMin = TIMER_PRESETS[nextIndex];
                    const nextSec = nextMin * 60;
                    settings.value.focusTimeSeconds = nextSec;
                    settings.value.pomodoro = nextMin;
                    localStorage.setItem('qa_settings', JSON.stringify(settings.value));
                    if (!isRunning.value && !isResting.value) time.value = 0;
                };

                const FOCUS_TIME = computed(() => settings.value.focusTimeSeconds || (settings.value.pomodoro * 60));
                const toggleScreen = () => { window.location.href = 'stats.html'; };

                const isClockMode = ref(true);
                watch(isClockMode, (newVal) => {
                    const appEl = document.getElementById('app');
                    if (newVal) appEl.classList.add('clock-mode');
                    else appEl.classList.remove('clock-mode');
                }, { immediate: true });

                const windows = ref(new Array(30).fill(false));
                const isRunning = ref(false);
                const isResting = ref(false);
                const time = ref(0);
                const timerInterval = ref(null);
                const heartbeatInterval = ref(null);
                const mode = ref(settings.value.mode === 'stopwatch' ? 'countup' : 'pomodoro');
                const myRoomIndex = ref(null); // Ref for my room
                const activeNeighbors = ref(0); // Ref for active neighbors

                // Time Display
                const formattedTime = computed(() => {
                    if (mode.value === 'countup') {
                        return formatTimeStr(time.value);
                    } else {
                        const remaining = Math.max(0, FOCUS_TIME.value - time.value);
                        return formatTimeStr(remaining);
                    }
                });

                const formattedTotalTime = computed(() => formatTimeStr(totalSeconds.value));

                // --- Core Logic ---
                const startTimer = () => {
                    if (isRunning.value) return;

                    // Reset if session was stale
                    if (time.value === 0) {
                        sessionStartTime.value = new Date();
                    }

                    isRunning.value = true;
                    isPaused.value = false;
                    isSaved.value = false;

                    // Light ON
                    if (myRoomIndex.value !== null) {
                        try {
                            const userStatusRef = db.ref(`rooms/${myRoomIndex.value}`);
                            userStatusRef.update({
                                active: true,
                                lastActive: firebase.database.ServerValue.TIMESTAMP
                            });
                        } catch (e) { console.error(e); }
                    }

                    timerInterval.value = setInterval(() => {
                        time.value++;
                        totalSeconds.value++;

                        // Timer Mode Finish
                        if (mode.value === 'pomodoro' && time.value >= FOCUS_TIME.value) {
                            finishSession();
                        }
                    }, 1000);

                    // Heartbeat (every 1 min)
                    const beat = () => {
                        if (userId.value) {
                            const today = new Date().toISOString().split('T')[0];
                            // Simple daily update to keep alive? Or just rely on disconnect
                            // Actually we need to update "rooms" status to prevent stale
                            if (myRoomIndex.value !== null) {
                                db.ref(`rooms/${myRoomIndex.value}`).update({
                                    lastActive: firebase.database.ServerValue.TIMESTAMP
                                });
                            }
                        }
                    };
                    heartbeatInterval.value = setInterval(beat, 60000);
                };

                const pauseTimer = () => {
                    clearInterval(timerInterval.value);
                    clearInterval(heartbeatInterval.value);
                    isRunning.value = false;
                    isPaused.value = true;
                    // Note: Light stays visible locally? Usually turned off in DB to show inactive?
                    // Let's turn off DB light to show "not focused" to neighbors
                    if (myRoomIndex.value !== null) {
                        db.ref(`rooms/${myRoomIndex.value}`).update({ active: false });
                    }
                };

                const resumeTimer = () => {
                    startTimer();
                };

                const finishSession = (tag = null) => {
                    stopAlarm();
                    clearInterval(timerInterval.value);
                    clearInterval(heartbeatInterval.value);
                    isRunning.value = false;
                    isPaused.value = false;
                    isResting.value = false;

                    // Light OFF
                    if (myRoomIndex.value !== null) {
                        db.ref(`rooms/${myRoomIndex.value}`).update({ active: false });
                    }

                    // Save Log
                    if (time.value >= 5 && userId.value) { // Only save >= 5 sec (changed from 60 for testing)
                        const log = {
                            start: sessionStartTime.value ? sessionStartTime.value.toISOString() : new Date().toISOString(),
                            duration: time.value,
                            mode: mode.value,
                            tag: tag || 'Focus'
                        };
                        db.ref(`users/${userId.value}/logs`).push(log);
                        isSaved.value = true;
                        // showToast(`Session Saved: ${tag || 'Focus'} (${formatTimeStr(time.value)})`);
                    }

                    // Reset
                    time.value = 0;
                    sessionStartTime.value = null;

                    // If Timer Mode -> Start Rest?
                    if (mode.value === 'pomodoro' && !tag) { // Automatic finish (no tag selected yet)
                        // Actually in this app, we ask for tag on pause/finish manually. 
                        // If time runs out, maybe just go to rest?
                        // Let's keep it simple: Just stop. User can start rest manually if implemented.
                        // Wait, previous code had "Rest" logic.
                        startRest();
                    }
                };

                const startRest = () => {
                    isResting.value = true;
                    if (settings.value.rest > 0) {
                        // Simple rest timer?
                        // For now just state isResting (UI changes blue-green)
                        // Maybe auto-start a rest timer? 
                        // Implementation simplified for resilience:
                        playAlarm(); // Ring when time is up
                        setTimeout(stopAlarm, 3000);
                    }
                };

                const handleMainButton = () => {
                    if (isResting.value) {
                        // End Rest
                        isResting.value = false;
                        time.value = 0;
                        stopAlarm();
                    } else if (isPaused.value) {
                        resumeTimer();
                    } else if (isRunning.value) {
                        pauseTimer();
                    } else {
                        startTimer();
                    }
                };

                const resetTimer = () => {
                    pauseTimer();
                    isPaused.value = false; // Hide pause menu
                    time.value = 0;
                    isSaved.value = true;
                };

                // Data Transfer Logic
                const copyText = (text) => {
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text).then(() => {
                            showToast('コピーしました');
                        }).catch(() => {
                            fallbackCopy(text);
                        });
                    } else {
                        fallbackCopy(text);
                    }
                };

                const updateUserId = () => {
                    const newId = importUserId.value.trim();
                    if (newId && newId !== userId.value) {
                        if (confirm(`ID: ${newId} にデータを切り替えますか？\n(現在の画面はリロードされます)`)) {
                            localStorage.setItem('qa_user_id', newId);
                            location.reload();
                        }
                    }
                };

                const fallbackCopy = (text) => {
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        showToast('コピーしました');
                    } catch (err) {
                        showToast('コピーに失敗しました');
                    }
                    document.body.removeChild(textArea);
                };

                // Initialize
                onMounted(() => {
                    // Auth / User ID
                    const urlParams = new URLSearchParams(window.location.search);
                    let uid = urlParams.get('uid');

                    if (uid) {
                        // Override with URL param
                        localStorage.setItem('qa_user_id', uid);
                    } else {
                        // Fallback to stored or generate
                        uid = localStorage.getItem('qa_user_id');
                        if (!uid) {
                            uid = 'u_' + Math.random().toString(36).substr(2, 9);
                            localStorage.setItem('qa_user_id', uid);
                        }
                    }
                    userId.value = uid;

                    // Dev Mode
                    if (window.location.hash === '#dev') {
                        isDev.value = true;
                        setTimeout(() => showToast('Developer Mode Active'), 1000);
                    }

                    // Room Allocation
                    // Try to find a free room or use existing
                    let savedRoom = localStorage.getItem('qa_room_index');
                    if (savedRoom) {
                        myRoomIndex.value = parseInt(savedRoom);
                    } else {
                        // Random allocation for now
                        const r = Math.floor(Math.random() * 24); // 0-23 typical windows
                        myRoomIndex.value = r;
                        localStorage.setItem('qa_room_index', r);
                    }

                    // Listen to Rooms
                    db.ref('rooms').on('value', (snap) => {
                        const val = snap.val() || {};
                        const arr = new Array(30).fill(false);
                        let count = 0;
                        for (const [key, room] of Object.entries(val)) {
                            const idx = parseInt(key);
                            if (room.active) {
                                // Check staleness (timeout 5 mins)
                                const now = Date.now();
                                if (now - room.lastActive < 300000) {
                                    if (idx !== myRoomIndex.value) {
                                        arr[idx] = true;
                                        count++;
                                    }
                                }
                            }
                        }
                        windows.value = arr;
                        activeNeighbors.value = count;
                    });

                    // Setup disconnect handler
                    if (myRoomIndex.value !== null) {
                        const roomRef = db.ref(`rooms/${myRoomIndex.value}`);
                        roomRef.onDisconnect().update({ active: false });
                    }
                });

                return {
                    userId,
                    totalSeconds,
                    isDev,
                    isTagEditMode,
                    isSaved,
                    activeNeighbors,
                    myRoomIndex,
                    newTagInput,

                    // State
                    currentTab,
                    showSettings,
                    importUserId,
                    isPaused,
                    tags,
                    toasts,
                    windows,

                    // Timer
                    isRunning,
                    isResting,
                    time,
                    mode,
                    isClockMode,

                    // Computed
                    settings,
                    formattedTime,
                    formattedTotalTime,

                    // Methods
                    saveSettings,
                    addTag,
                    deleteTag,
                    toggleScreen,
                    toggleMode,
                    handleMainButton,
                    resetTimer,
                    cycleTimerDuration,
                    finishSession,
                    copyText,
                    updateUserId
                };
            }
        }).mount('#app');
    </script>
</body>

</html>